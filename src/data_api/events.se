# Copyright (C) 2015 Forecast Foundation OU, full GPL notice in LICENSE

extern controller: [lookup:[int256]:int256, assertIsWhitelisted:[int256]:int256]

REGISTRATION_TOKEN = self.controller.lookup('registrationToken')
extern registrationToken: [a:[]:_]

REPUTATION_TOKEN = self.controller.lookup('reputationToken')
extern reputationToken: [b:[]:_]

BRANCHES = self.controller.lookup('branchActions')
extern branches: [c:[]:_]

REPORTING = self.controller.lookup('reporting')
extern reporting: [d:[]:_]

extern market: [initialize:[uint256,address,uint256,str,address]:_, getBranch:[]:address, getMarketId:[]:uint256, getReportingWindow:[]:uint256]

inset('../macros/refund.sem')
inset('../macros/safeMath.sem')
inset('../macros/assertPrivateCall.sem')
inset('../macros/unitConversions.sem')

data controller

data nextMarketId
data markets[2**64]
# takes branch, reportingWindow, phase
data marketCounts[][][]

def init():
    self.controller = 0x0
    self.nextMarketId = 1

def any():
    refund()

def createMarket(branch, endTime, description, automatedReporterAddress):
    # TODO: assert not a duplicate event. CONSIDER: is this actually necessary?
    marketId = self.nextMarketId
    self.nextMarketId += 1
    newMarket = create('market', value = msg.value)
    newMarket.initialize(marketId, branch, endTime, description, automatedReporterAddress)
    self.markets[marketId] = newMarket
    marketCounts[newMarket.getBranch()][newMarket.getReportingWindow()][2] += 1
    return(newMarket)

# FIXME: figure out a better way to deal with limited/all reporters market counts. what we want to do is:
#   FIXME: markets
#   FIXME:     .filter(market => market.branchId == branch)
#   FIXME:     .filter(market => market.reportingWindow == reportingWindow)
#   FIXME:     .filter(market => market.getReportingPhase() == <limited/all>)
#   FIXME:     .count()
#   FIXME: but we can't do unbounded operations like that in the EVM, so we need a solution that involves keeping a running count as markets move between branches/reporting windows/phases. if a better solution isn't found then this code will need some extensive auditing to ensure we don't miss any movements
def notifyMarketMovement(market, oldBranch, newBranch, oldReportingWindow, newReportingWindow, oldPhase, newPhase):
    self.assertMarketIsAugurMarket(msg.sender)
    self.marketCounts[oldBranch][oldReportingWindow][oldPhase] -= 1
    self.marketCounts[newBranch][newReportingWindow][newPhase] += 1

####
#### Getters
####

def getMarket(marketId):
    market = self.markets[marketId]
    if (not market):
        ~invalid()
    return(market)

def getNumberOfLimitedReporterEvents(branch, reportingWindow):
    return(self.marketCounts[branch][reportingWindow][2])

def getNumberOfAllReporterEvents(branch, reportingWindow):
    return(self.marketCounts[branch][reportingWindow][3])

####
#### Asserts
####

def assertMarketIsAugurMarket(market):
    if (self.markets[market.getMarketId()] != market):
        ~invalid()

####
#### Private
####
