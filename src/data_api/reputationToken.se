# Copyright (C) 2015 Forecast Foundation OU, full GPL notice in LICENSE

extern controller: [lookup:[int256]:int256, assertIsWhitelisted:[int256]:int256]

# TODO: change this to match the address of the REP contract on the target network
LEGACY_REP_CONTRACT = 0x0
extern legacyRepContract: [a:[]:_]

inset('../macros/safeMath.sem')
inset('../macros/assertPrivateCall.sem')
inset('../macros/refund.sem')
inset('../macros/unitConversions.sem')

data controller
# tokens[branch][token_holder_address] returns attorep
data tokens[][2**160]
# spenders[branch][token_holder_address][spender_address] returns attorep
data spenders[][2**160][2**160]
# tokenSupply[branch] returns attorep
data tokenSupply[]
data name
data symbol
data decimals

event Transfer(branch:uint256:indexed, from:address:indexed, to:address:indexed, attorep:uint256)
event Approval(branch:uint256:indexed, owner:address:indexed, spender:address:indexed, attorep:uint256)

def init():
    self.controller = 0x0
    self.name = "Reputation"
    self.symbol = "REP"
    self.decimals = 18
    faucetDistribution = 1000000 * WEI_TO_ETH
    self.tokens[branch][self.controller.lookup('reputationFaucet')] += faucetDistribution
    self.tokenSupply[branch] += faucetDistribution

    # CONSIDER: should we copy over contents of 0x0000000000000000000000000000000000000000 from LEGACYREPCONTRACT? if so what do we do with them?

def any():
    refund()

def migrate(parentBranch, childBranch, attorepToMigrate):
    BRANCHES.assertParentChildRelationship(parentBranch, childBranch)
    # do the transfer
    startingTokensOnParent = self.tokens[sourceBranch][msg.sender]
    startingTokensOnChild = self.tokens[destinationBranch][msg.sender]
    startingSupplyOnParent = self.tokenSupply[sourceBranch]
    startingSupplyOnChild = self.tokenSupply[destinationBranch]
    self.tokens[sourceBranch][msg.sender] = safeSub(startingTokensOnParent, attorepToMigrate)
    self.tokens[destinationBranch][msg.sender] = safeAdd(startingTokensOnChild, attorepToMigrate)
    self.tokenSupply[sourceBranch] = safeSub(startingSupplyOnParent, attorepToMigrate)
    self.tokenSupply[destinationBranch] = safeAdd(startingSupplyOnChild, attorepToMigrate)
    return(1)

def migrateFromLegacyRepContract(branch):
    legacyBalance = LEGACY_REP_CONTRACT.balanceOf(msg.sender)
    startingBalance = self.tokens[branch][msg.sender]
    startingSupply = self.tokenSupply[branch]
    LEGACY_REP_CONTRACT.transferFrom(msg.sender, 0x0000000000000000000000000000000000000000, legacyBalance)
    self.tokens[branch][msg.sender] = safeAdd(startingBalance, legacyBalance)
    self.tokenSupply[branch] = safeAdd(startingSupply, legacyBalance)
    return(1)

####
#### ERC20-like implementation
####

def totalSupply(branch):
    return(self.tokenSupply[branch]: uint256)

def balanceOf(branch, address):
    return(self.tokens[branch][address]: uint256)

def transfer(branch, destinationAddress, attorep):
    return(self.privateTransfer(branch, msg.sender, destinationAddress, attorep))

def transferFrom(branch, sourceAddress, destinationAddress, attorep):
    startingLimit = self.spenders[branch][sourceAddress][msg.sender]
    self.spenders[branch][sourceAddress][msg.sender] = safeSub(startingLimit, attorep)
    return(self.privateTransfer(branch, sourceAddress, destinationAddress, attorep))

def approve(branch, spenderAddress, attorep):
    self.spenders[branch][msg.sender][spenderAddress] = attorep
    log(type = Approval, branch, msg.sender, spenderAddress, attorep)
    return(1)

def allowance(branch, ownerAddress, spenderAddress):
    return(self.spenders[branch][ownerAddress][spenderAddress]: uint256)

####
#### Private
####

def privateTransfer(branch, sourceAddress, destinationAddress, attorep):
    assertPrivateCall()
    startingSourceAttoRep = self.tokens[branch][sourceAddress]
    startingDestinationAttoRep = self.tokens[branch][destinationAddress]
    self.tokens[branch][sourceAddress] = safeSub(startingSourceAttoRep, attorep)
    self.tokens[branch][destinationAddress] = safeAdd(startingDestinationAttoRep, attorep)
    log(type = Transfer, branch, sourceAddress, destinationAddress, attorep)
    return(1)
