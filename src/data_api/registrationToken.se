# Copyright (C) 2015 Forecast Foundation OU, full GPL notice in LICENSE

extern controller: [lookup:[int256]:int256, assertIsWhitelisted:[int256]:int256]

BRANCHES = self.controller.lookup('branches')
extern branches: [a:[]:_]

REPORTING = self.controller.lookup('reporting')
extern reporting: [b:[]:_]

REPUTATION_TOKEN = self.controller.lookup('reputationToken')
extern reputationToken: [c:[]:_]

inset('../macros/safeMath.sem')
inset('../macros/assertPrivateCall.sem')
inset('../macros/refund.sem')

data controller
# bond amount in attorep
data bondAmount
# tokens[branch][reporting_window][token_holder_address] returns count of registration tokens
data tokens[][][2**160]
# spenders[branch][reporting_window][token_holder_address][token_spender_address] returns count of registration tokens
data spenders[][][2**160][2**160]
# tokenSupply[branch][reporting_window] returns a count of outstanding registration tokens
data tokenSupply[][]

event Transfer(branch:uint256:indexed, reportingWindow:uint256, from:address:indexed, to:address:indexed, attorep:uint256)
event Approval(branch:uint256:indexed, reportingWindow:uint256, owner:address:indexed, spender:address:indexed, attorep:uint256)

def init():
    self.controller = 0x0
    # TODO: make this dynamically adjust based on the rate of bond forfeitures in previous preporting window(s)
    self.bondAmount = 10**18

def any():
    refund()

def register(branch, reportingWindow):
    # do not allow for registration for reporting in the current window
    if (reportingWindow <= REPORTING.getCurrentReportingWindow()):
        ~invalid()
    REPUTATION_TOKEN.transferFrom(branch, msg.sender, self, bondAmount)
    startingTokens = self.tokens[branch][reportingWindow][msg.sender]
    self.tokens[branch][reportingWindow][msg.sender] = safeAdd(startingRegistrationTokens, 1)

def migrate(parentBranch, childBranch, reportingWindow, tokensToMigrate):
    BRANCHES.assertParentChildRelationship(parentBranch, childBranch)
    # do the transfer
    startingTokensOnParent = self.tokens[parentBranch][reportingWindow][msg.sender]
    startingTokensOnChild = self.tokens[childBranch][reportingWindow][msg.sender]
    startingSupplyOnParent = self.tokenSupply[parentBranch][reportingWindow]
    startingSupplyOnChild = self.tokenSupply[childBranch][reportingWindow]
    self.tokens[parentBranch][reportingWindow][msg.sender] = safeSub(startingTokensOnParent, tokensToMigrate)
    self.tokens[childBranch][reportingWindow][msg.sender] = safeAdd(startingTokensOnChild, tokensToMigrate)
    self.tokenSupply[parentBranch][reportingWindow] = safeSub(startingSupplyOnParent, tokensToMigrate)
    self.tokenSupply[childBranch][reportingWindow] = safeAdd(startingSupplyOnChild, tokensToMigrate)
    return(1)

def redeem(branch, reportingWindow):
    startingTokens = self.tokens[branch][reportingWindow][msg.sender]
    startingSupply = self.tokenSupply[branch][reportingWindow]
    reportingContract = self.controller.lookup('reporting')
    reportingContract.assertDoneReporting(branch, reportingWindow, msg.sender)
    self.tokens[branch][reportingWindow][msg.sender] = safeSub(startingTokens, 1)
    self.tokenSupply[branch][reportingWindow] = safeSub(startingSupply, 1)
    reportingContract.clearUserReports(branch, reportingWindow, msg.sender)
    self.controller.lookup('reputation').transfer(branch, msg.sender, self.bondAmount)

####
#### ERC20-like implementation
####

def totalSupply(branch, reportingWindow):
	return(self.tokenSupply[branch][reportingWindow]: uint256)

def balanceOf(branch, reportingWindow, address):
	return(self.tokens[branch][reportingWindow][address]: uint256)

def transfer(branch, reportingWindow, destinationAddress, attorep):
    return(self.privateTransfer(branch, reportingWindow, msg.sender, destinationAddress, attorep))

def transferFrom(branch, reportingWindow, sourceAddress, destinationAddress, attorep):
    startingLimit = self.spenders[branch][reportingWindow][sourceAddress][msg.sender]
    self.spenders[branch][reportingWindow][sourceAddress][msg.sender] = safeSub(startingLimit, attorep)
    return(self.privateTransfer(branch, reportingWindow, sourceAddress, destinationAddress, attorep))

def approve(branch, reportingWindow, spenderAddress, attorep):
    self.spenders[branch][reportingWindow][msg.sender][spenderAddress] = attorep
    log(type = Approval, branch, reportingWindow, msg.sender, spenderAddress, attorep)
    return(1)

def allowance(branch, reportingWindow, ownerAddress, spenderAddress):
    return(self.spenders[branch][reportingWindow][ownerAddress][spenderAddress]: uint256)

####
#### Private
####

def privateTransfer(branch, reportingWindow, sourceAddress, destinationAddress, attorep):
    assertPrivateCall()
    startingSourceTokens = self.tokens[branch][reportingWindow][sourceAddress]
    startingDestinationTokens = self.tokens[branch][reportingWindow][destinationAddress]
    self.tokens[branch][reportingWindow][sourceAddress] = safeSub(startingSourceTokens, attorep)
    self.tokens[branch][reportingWindow][destinationAddress] = safeAdd(startingDestinationTokens, attorep)
    log(type = Transfer, branch, reportingWindow, sourceAddress, destinationAddress, attorep)
    return(1)
